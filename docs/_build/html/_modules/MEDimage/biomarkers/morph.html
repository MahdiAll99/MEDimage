<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MEDimage.biomarkers.morph &mdash; MEDimage  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> MEDimage
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">MEDimage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../FAQs.html">FAQs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MEDimage</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>MEDimage.biomarkers.morph</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MEDimage.biomarkers.morph</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>
<span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">marching_cubes</span>

<span class="kn">from</span> <span class="nn">..biomarkers.get_oriented_bound_box</span> <span class="kn">import</span> <span class="n">rot_matrix</span><span class="p">,</span> <span class="n">sig_proc_find_peaks</span>


<div class="viewcode-block" id="get_mesh"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.get_mesh">[docs]</a><span class="k">def</span> <span class="nf">get_mesh</span><span class="p">(</span><span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">res</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Compute Mesh.</span>

<span class="sd">    Note:</span>
<span class="sd">      Make sure the `mask` is padded with a layer of 0&#39;s in all</span>
<span class="sd">      dimensions to reduce potential isosurface computation errors.</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (ndarray): Contains only 0&#39;s and 1&#39;s.</span>
<span class="sd">        res (ndarray or List): [a,b,c] vector specifying the resolution of the volume in mm.</span>
<span class="sd">            xyz resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.ndarray, np.ndarray, np.ndarray]: </span>
<span class="sd">            - Array of the [X,Y,Z] positions of the ROI.</span>
<span class="sd">            - Array of the spatial coordinates for `mask` unique mesh vertices.</span>
<span class="sd">            - Array of triangular faces via referencing vertex indices from vertices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Getting the grid of X,Y,Z positions, where the coordinate reference</span>
    <span class="c1"># system (0,0,0) is located at the upper left corner of the first voxel</span>
    <span class="c1"># (-0.5: half a voxel distance). For the whole volume defining the mask,</span>
    <span class="c1"># no matter if it is a 1 or a 0.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

    <span class="c1"># Getting the isosurface of the mask</span>
    <span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">marching_cubes</span><span class="p">(</span><span class="n">volume</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">res</span><span class="p">)</span>

    <span class="c1"># Getting the X,Y,Z positions of the ROI (i.e. 1&#39;s) of the mask</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">Y</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">Z</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>

    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span></div>

<div class="viewcode-block" id="get_com"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.get_com">[docs]</a><span class="k">def</span> <span class="nf">get_com</span><span class="p">(</span><span class="n">xgl_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">xgl_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">xyz_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">xyz_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Calculates center of mass shift (in mm, since resolution is in mm).</span>

<span class="sd">    Note: </span>
<span class="sd">        Row positions of &quot;x_gl&quot; and &quot;xyz&quot; must correspond for each point.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        xgl_int (ndarray): Vector of intensity values in the volume to analyze </span>
<span class="sd">            (only values in the intensity mask).</span>
<span class="sd">        xgl_morph (ndarray): Vector of intensity values in the volume to analyze </span>
<span class="sd">            (only values in the morphological mask).</span>
<span class="sd">        xyz_int (ndarray): [n_points X 3] matrix of three column vectors, defining the [X,Y,Z]</span>
<span class="sd">            positions of the points in the ROI (1&#39;s) of the mask volume (In mm).</span>
<span class="sd">            (Mesh-based volume calculated from the ROI intensity mesh)</span>
<span class="sd">        xyz_morph (ndarray): [n_points X 3] matrix of three column vectors, defining the [X,Y,Z]</span>
<span class="sd">            positions of the points in the ROI (1&#39;s) of the mask volume (In mm).</span>
<span class="sd">            (Mesh-based volume calculated from the ROI morphological mesh)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[float, np.ndarray]: The ROI volume centre of mass.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Getting the geometric centre of mass</span>
    <span class="n">n_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xgl_morph</span><span class="p">)</span>

    <span class="n">com_geom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xyz_morph</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">n_v</span>  <span class="c1"># [1 X 3] vector</span>

    <span class="c1"># Getting the density centre of mass</span>
    <span class="n">xyz_int</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xgl_int</span><span class="o">*</span><span class="n">xyz_int</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">xyz_int</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xgl_int</span><span class="o">*</span><span class="n">xyz_int</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">xyz_int</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xgl_int</span><span class="o">*</span><span class="n">xyz_int</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">com_gl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xyz_int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xgl_int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># [1 X 3] vector</span>

    <span class="c1"># Calculating the shift</span>
    <span class="n">com</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">com_geom</span> <span class="o">-</span> <span class="n">com_gl</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">com</span></div>

<div class="viewcode-block" id="get_area_dens_approx"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.get_area_dens_approx">[docs]</a><span class="k">def</span> <span class="nf">get_area_dens_approx</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                         <span class="n">b</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                         <span class="n">c</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                         <span class="n">n</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes area density - minimum volume enclosing ellipsoid</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        a (float): Major semi-axis length.</span>
<span class="sd">        b (float): Minor semi-axis length.</span>
<span class="sd">        c (float): Least semi-axis length.</span>
<span class="sd">        n (int): Number of iterations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Area density - minimum volume enclosing ellipsoid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ab</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">beta</span>
    <span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">beta</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">ab</span><span class="p">)</span>
    <span class="n">a_ell</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">legen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">point</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">coef</span><span class="p">)</span>
        <span class="n">a_ell</span> <span class="o">=</span> <span class="n">a_ell</span> <span class="o">+</span> <span class="n">ab</span><span class="o">**</span><span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">legen</span>

    <span class="n">a_ell</span> <span class="o">=</span> <span class="n">a_ell</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

    <span class="k">return</span> <span class="n">a_ell</span></div>

<div class="viewcode-block" id="get_axis_lengths"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.get_axis_lengths">[docs]</a><span class="k">def</span> <span class="nf">get_axis_lengths</span><span class="p">(</span><span class="n">xyz</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Computes AxisLengths.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        xyz (ndarray): Array of three column vectors, defining the [X,Y,Z]</span>
<span class="sd">            positions of the points in the ROI (1&#39;s) of the mask volume. In mm.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[float, float, float]: Array of three column vectors </span>
<span class="sd">        [Major axis lengths, Minor axis lengths, Least axis lengths].</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Getting the geometric centre of mass</span>
    <span class="n">com_geom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">xyz</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># [1 X 3] vector</span>

    <span class="c1"># Subtracting the centre of mass</span>
    <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_geom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_geom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">com_geom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Getting the covariance matrix</span>
    <span class="n">cov_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Getting the eigenvalues</span>
    <span class="n">eig_val</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov_mat</span><span class="p">)</span>
    <span class="n">eig_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">eig_val</span><span class="p">)</span>

    <span class="n">major</span> <span class="o">=</span> <span class="n">eig_val</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">minor</span> <span class="o">=</span> <span class="n">eig_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">least</span> <span class="o">=</span> <span class="n">eig_val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">least</span></div>

<div class="viewcode-block" id="min_oriented_bound_box"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.min_oriented_bound_box">[docs]</a><span class="k">def</span> <span class="nf">min_oriented_bound_box</span><span class="p">(</span><span class="n">pos_mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes the minimum bounding box of an arbitrary solid: an iterative approach.</span>
<span class="sd">    This feature refers to &quot;Volume density (oriented minimum bounding box)&quot; (ID = ZH1A)  </span>
<span class="sd">    in the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        pos_mat (ndarray): matrix position</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: return bounding box dimensions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">##########################</span>
    <span class="c1"># Internal functions</span>
    <span class="c1">##########################</span>

    <span class="k">def</span> <span class="nf">calc_rot_aabb_surface</span><span class="p">(</span><span class="n">theta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                              <span class="n">hull_mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Function to calculate surface of the axis-aligned bounding box of a rotated 2D contour</span>

<span class="sd">        Args:</span>
<span class="sd">            theta (float): angle in radian</span>
<span class="sd">            hull_mat (nddarray): convex hull matrix</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: the surface of the axis-aligned bounding box of a rotated 2D contour</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create rotation matrix and rotate over theta</span>
        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">rot_hull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">,</span> <span class="n">hull_mat</span><span class="p">)</span>

        <span class="c1"># Calculate bounding box surface of the rotated contour</span>
        <span class="n">rot_aabb_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rot_hull</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rot_hull</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rot_aabb_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">rot_aabb_dims</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rot_aabb_area</span>

    <span class="k">def</span> <span class="nf">approx_min_theta</span><span class="p">(</span><span class="n">hull_mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">theta_sel</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                         <span class="n">res</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                         <span class="n">max_rep</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Iterative approximator for finding angle theta that minimises surface area</span>

<span class="sd">        Args:</span>
<span class="sd">            hull_mat (ndarray): convex hull matrix</span>
<span class="sd">            theta_sel (float): angle in radian</span>
<span class="sd">            res (float): value in radian</span>
<span class="sd">            max_rep (int, optional): maximum repetition. Defaults to 5.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ndarray: the angle theta that minimises surfae area</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_rep</span><span class="p">):</span>

            <span class="c1"># Select new thetas in vicinity of</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">theta_sel</span><span class="o">-</span><span class="n">res</span><span class="p">,</span> <span class="n">theta_sel</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">res</span><span class="p">,</span>
                              <span class="n">theta_sel</span><span class="p">,</span> <span class="n">theta_sel</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">theta_sel</span><span class="o">+</span><span class="n">res</span><span class="p">])</span>

            <span class="c1"># Calculate projection areas for current angles theta</span>
            <span class="n">rot_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">calc_rot_aabb_surface</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">hull_mat</span><span class="o">=</span><span class="n">hull_mat</span><span class="p">),</span> <span class="n">theta</span><span class="p">)))</span>

            <span class="c1"># Find global minimum and corresponding angle theta_sel</span>
            <span class="n">theta_sel</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">rot_area</span><span class="p">)]</span>

            <span class="c1"># Shrink resolution and iterate</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="k">return</span> <span class="n">theta_sel</span>

    <span class="k">def</span> <span class="nf">rotate_minimal_projection</span><span class="p">(</span><span class="n">input_pos</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                  <span class="n">rot_axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                  <span class="n">n_minima</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                  <span class="n">res_init</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to that rotates input_pos to find the rotation that</span>
<span class="sd">        minimises the projection of input_pos on the</span>
<span class="sd">        plane normal to the rot_axis</span>

<span class="sd">        Args:</span>
<span class="sd">            input_pos (float): input position value</span>
<span class="sd">            rot_axis (int): rotation axis value</span>
<span class="sd">            n_minima (int, optional): _description_. Defaults to 3.</span>
<span class="sd">            res_init (float, optional): _description_. Defaults to 5.0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            _type_: _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># Find axis aligned bounding box of the point set</span>
        <span class="n">aabb_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">input_pos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">aabb_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">input_pos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Center the point set at the AABB center</span>
        <span class="n">output_pos</span> <span class="o">=</span> <span class="n">input_pos</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">aabb_min</span> <span class="o">+</span> <span class="n">aabb_max</span><span class="p">)</span>

        <span class="c1"># Project model to plane</span>
        <span class="n">proj_pos</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">output_pos</span><span class="p">)</span>
        <span class="n">proj_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">proj_pos</span><span class="p">,</span> <span class="p">[</span><span class="n">rot_axis</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Calculate 2D convex hull of the model projection in plane</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">proj_pos</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">hull_2d</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">proj_pos</span><span class="p">)</span>
            <span class="n">hull_mat</span> <span class="o">=</span> <span class="n">proj_pos</span><span class="p">[</span><span class="n">hull_2d</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">del</span> <span class="n">hull_2d</span><span class="p">,</span> <span class="n">proj_pos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hull_mat</span> <span class="o">=</span> <span class="n">proj_pos</span>
            <span class="k">del</span> <span class="n">proj_pos</span>

        <span class="c1"># Transpose hull_mat so that the array is (ndim, npoints) instead of (npoints, ndim)</span>
        <span class="n">hull_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">hull_mat</span><span class="p">)</span>

        <span class="c1"># Calculate bounding box surface of a series of rotated contours</span>
        <span class="c1"># Note we can program a min-search algorithm here as well</span>

        <span class="c1"># Calculate initial surfaces</span>
        <span class="n">theta_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mf">90.0</span> <span class="o">+</span>
                               <span class="n">res_init</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">res_init</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span>
        <span class="n">rot_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">calc_rot_aabb_surface</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">hull_mat</span><span class="o">=</span><span class="n">hull_mat</span><span class="p">),</span> <span class="n">theta_init</span><span class="p">)))</span>

        <span class="c1"># Find local minima</span>
        <span class="n">df_min</span> <span class="o">=</span> <span class="n">sig_proc_find_peaks</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">rot_area</span><span class="p">,</span> <span class="n">ddir</span><span class="o">=</span><span class="s2">&quot;neg&quot;</span><span class="p">)</span>

        <span class="c1"># Check if any minimum was generated</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_min</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Investigate up to n_minima number of local minima, starting with the global minimum</span>
            <span class="n">df_min</span> <span class="o">=</span> <span class="n">df_min</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;val&quot;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Determine max number of minima evaluated</span>
            <span class="n">max_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">n_minima</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">df_min</span><span class="p">)])</span>

            <span class="c1"># Initialise place holder array</span>
            <span class="n">theta_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span>

            <span class="c1"># Iterate over local minima</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">):</span>

                <span class="c1"># Find initial angle corresponding to i-th minimum</span>
                <span class="n">sel_ind</span> <span class="o">=</span> <span class="n">df_min</span><span class="o">.</span><span class="n">ind</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">theta_curr</span> <span class="o">=</span> <span class="n">theta_init</span><span class="p">[</span><span class="n">sel_ind</span><span class="p">]</span>

                <span class="c1"># Zoom in to improve the approximation of theta</span>
                <span class="n">theta_min</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">approx_min_theta</span><span class="p">(</span>
                    <span class="n">hull_mat</span><span class="o">=</span><span class="n">hull_mat</span><span class="p">,</span> <span class="n">theta_sel</span><span class="o">=</span><span class="n">theta_curr</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res_init</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span><span class="p">)</span>

            <span class="c1"># Calculate surface areas corresponding to theta_min and theta that</span>
            <span class="c1"># minimises the surface</span>
            <span class="n">rot_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">calc_rot_aabb_surface</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">hull_mat</span><span class="o">=</span><span class="n">hull_mat</span><span class="p">),</span> <span class="n">theta_min</span><span class="p">)))</span>
            <span class="n">theta_sel</span> <span class="o">=</span> <span class="n">theta_min</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">rot_area</span><span class="p">)]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">theta_sel</span> <span class="o">=</span> <span class="n">theta_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Rotate original point along the angle that minimises the projected AABB area</span>
        <span class="n">output_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">output_pos</span><span class="p">)</span>
        <span class="n">rot_mat</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="p">(</span><span class="n">theta</span><span class="o">=</span><span class="n">theta_sel</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">rot_axis</span><span class="o">=</span><span class="n">rot_axis</span><span class="p">)</span>
        <span class="n">output_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">,</span> <span class="n">output_pos</span><span class="p">)</span>

        <span class="c1"># Rotate output_pos back to (npoints, ndim)</span>
        <span class="n">output_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">output_pos</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output_pos</span>

    <span class="c1">##########################</span>
    <span class="c1"># Main function</span>
    <span class="c1">##########################</span>

    <span class="n">rot_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;rot_axis_0&quot;</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
                           <span class="s2">&quot;rot_axis_1&quot;</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                           <span class="s2">&quot;rot_axis_2&quot;</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
                           <span class="s2">&quot;aabb_axis_0&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span>
                           <span class="s2">&quot;aabb_axis_1&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span>
                           <span class="s2">&quot;aabb_axis_2&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span>
                           <span class="s2">&quot;vol&quot;</span><span class="p">:</span>         <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">)})</span>

    <span class="c1"># Rotate over different sequences</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rot_df</span><span class="p">)):</span>
        <span class="c1"># Create a local copy</span>
        <span class="n">work_pos</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">pos_mat</span><span class="p">)</span>

        <span class="c1"># Rotate over sequence of rotation axes</span>
        <span class="n">work_pos</span> <span class="o">=</span> <span class="n">rotate_minimal_projection</span><span class="p">(</span>
            <span class="n">input_pos</span><span class="o">=</span><span class="n">work_pos</span><span class="p">,</span> <span class="n">rot_axis</span><span class="o">=</span><span class="n">rot_df</span><span class="o">.</span><span class="n">rot_axis_0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">work_pos</span> <span class="o">=</span> <span class="n">rotate_minimal_projection</span><span class="p">(</span>
            <span class="n">input_pos</span><span class="o">=</span><span class="n">work_pos</span><span class="p">,</span> <span class="n">rot_axis</span><span class="o">=</span><span class="n">rot_df</span><span class="o">.</span><span class="n">rot_axis_1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">work_pos</span> <span class="o">=</span> <span class="n">rotate_minimal_projection</span><span class="p">(</span>
            <span class="n">input_pos</span><span class="o">=</span><span class="n">work_pos</span><span class="p">,</span> <span class="n">rot_axis</span><span class="o">=</span><span class="n">rot_df</span><span class="o">.</span><span class="n">rot_axis_2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Determine resultant minimum bounding box</span>
        <span class="n">aabb_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">work_pos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">work_pos</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">rot_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;aabb_axis_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aabb_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rot_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;aabb_axis_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aabb_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rot_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;aabb_axis_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aabb_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">rot_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;vol&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">aabb_dims</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">work_pos</span><span class="p">,</span> <span class="n">aabb_dims</span>

    <span class="c1"># Find minimal volume of all rotations and return bounding box dimensions</span>
    <span class="n">sel_row</span> <span class="o">=</span> <span class="n">rot_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rot_df</span><span class="o">.</span><span class="n">vol</span><span class="o">.</span><span class="n">idxmin</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">ombb_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">sel_row</span><span class="o">.</span><span class="n">aabb_axis_0</span><span class="p">,</span> <span class="n">sel_row</span><span class="o">.</span><span class="n">aabb_axis_1</span><span class="p">,</span> <span class="n">sel_row</span><span class="o">.</span><span class="n">aabb_axis_2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ombb_dims</span></div>

<div class="viewcode-block" id="get_moran_i"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.get_moran_i">[docs]</a><span class="k">def</span> <span class="nf">get_moran_i</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">res</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Moran&#39;s Index.</span>
<span class="sd">    This feature refers to &quot;Morans I index&quot; (ID = N365)  </span>
<span class="sd">    in the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        res (List[float]): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">            XYZ resolution (world) or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of Moran&#39;s Index.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Find the location(s) of all non NaNs voxels</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span>
    <span class="n">n_vox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

    <span class="c1"># Get the mean</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vol</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vol</span><span class="p">[:])])</span>
    <span class="n">vol_mean</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span>  <span class="c1"># (x_gl,i - u)</span>
    <span class="n">vol_m_mean_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># (x_gl,i - u).^2</span>
    <span class="c1"># Sum of (x_gl,i - u).^2 over all i</span>
    <span class="n">sum_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vol_m_mean_s</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vol_m_mean_s</span><span class="p">[:])])</span>

    <span class="c1"># Get a meshgrid first</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">vol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">vol</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">vol</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sum_w</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_vox</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Distance mesh</span>
        <span class="n">temp_x</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">temp_y</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">temp_z</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">-</span> <span class="n">Z</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># meshgrid of weigths</span>
        <span class="n">temp_dist_mesh</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">temp_y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">temp_z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Removing NaNs</span>
        <span class="n">temp_dist_mesh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vol</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">temp_dist_mesh</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="c1"># Running sum of weights</span>
        <span class="n">w_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp_dist_mesh</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">temp_dist_mesh</span><span class="p">[:])])</span>
        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">sum_w</span> <span class="o">+</span> <span class="n">w_sum</span>

        <span class="c1"># Inside sum calculation</span>
        <span class="c1"># Removing NaNs</span>
        <span class="n">temp_vol</span> <span class="o">=</span> <span class="n">vol_mean</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">temp_vol</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">temp_vol</span> <span class="o">=</span> <span class="n">temp_dist_mesh</span> <span class="o">*</span> <span class="n">temp_vol</span>  <span class="c1"># (wij .* (x_gl,j - u))</span>
        <span class="c1"># Summing (wij .* (x_gl,j - u)) over all j</span>
        <span class="n">sum_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp_vol</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">temp_vol</span><span class="p">[:])])</span>
        <span class="c1"># Running sum of (x_gl,i - u)*(wij .* (x_gl,j - u)) over all i</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">vol_mean</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">sum_val</span>

    <span class="n">moran_i</span> <span class="o">=</span> <span class="n">temp</span><span class="o">*</span><span class="n">n_vox</span><span class="o">/</span><span class="n">sum_s</span><span class="o">/</span><span class="n">sum_w</span>

    <span class="k">return</span> <span class="n">moran_i</span></div>

<div class="viewcode-block" id="get_mesh_volume"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.get_mesh_volume">[docs]</a><span class="k">def</span> <span class="nf">get_mesh_volume</span><span class="p">(</span><span class="n">faces</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">vertices</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes MeshVolume feature.</span>
<span class="sd">    This feature refers to &quot;Volume (mesh)&quot; (ID = RNU0)  </span>
<span class="sd">    in the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        faces (np.ndarray): matrix of three column vectors, defining the [X,Y,Z]</span>
<span class="sd">                          positions of the ``faces`` of the isosurface or convex hull of the mask</span>
<span class="sd">                          (output from &quot;isosurface.m&quot; or &quot;convhull.m&quot; functions of MATLAB).</span>
<span class="sd">                          --&gt; These are more precisely indexes to ``vertices``</span>
<span class="sd">        vertices (np.ndarray): matrix of three column vectors, defining the</span>
<span class="sd">                             [X,Y,Z] positions of the ``vertices`` of the isosurface of the mask (output</span>
<span class="sd">                             from &quot;isosurface.m&quot; function of MATLAB).</span>
<span class="sd">                             --&gt; In mm.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Mesh volume</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Getting vectors for the three vertices</span>
    <span class="c1"># (with respect to origin) of each face</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:]</span>

    <span class="c1"># Calculating volume</span>
    <span class="n">v_cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">v_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">*</span><span class="n">v_cross</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v_dot</span><span class="p">))</span><span class="o">/</span><span class="mi">6</span>

    <span class="k">return</span> <span class="n">volume</span></div>

<div class="viewcode-block" id="get_mesh_area"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.get_mesh_area">[docs]</a><span class="k">def</span> <span class="nf">get_mesh_area</span><span class="p">(</span><span class="n">faces</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes the surface area (mesh) feature from the ROI mesh by </span>
<span class="sd">    summing over the triangular face surface areas. </span>
<span class="sd">    This feature refers to &quot;Surface area (mesh)&quot; (ID = C0JK)  </span>
<span class="sd">    in the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        faces (np.ndarray): matrix of three column vectors, defining the [X,Y,Z]</span>
<span class="sd">                          positions of the ``faces`` of the isosurface or convex hull of the mask</span>
<span class="sd">                          (output from &quot;isosurface.m&quot; or &quot;convhull.m&quot; functions of MATLAB).</span>
<span class="sd">                          --&gt; These are more precisely indexes to ``vertices``</span>
<span class="sd">        vertices (np.ndarray): matrix of three column vectors,</span>
<span class="sd">                             defining the [X,Y,Z]</span>
<span class="sd">                             positions of the ``vertices`` of the isosurface of the mask (output</span>
<span class="sd">                             from &quot;isosurface.m&quot; function of MATLAB).</span>
<span class="sd">                             --&gt; In mm.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Mesh area.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">faces</span> <span class="o">=</span> <span class="n">faces</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Getting two vectors of edges for each face</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">vertices</span><span class="p">[</span><span class="n">faces</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>

    <span class="c1"># Calculating the surface area of each face and summing it up all at once.</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">area</span></div>

<div class="viewcode-block" id="get_geary_c"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.get_geary_c">[docs]</a><span class="k">def</span> <span class="nf">get_geary_c</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Geary&#39;C measure (Assesses intensity differences between voxels).</span>
<span class="sd">    This feature refers to &quot;Geary&#39;s C measure&quot; (ID = NPT7) </span>
<span class="sd">    in the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: computes value of Geary&#39;C measure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Find the location(s) of all non NaNs voxels</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vol</span><span class="p">))</span>
    <span class="n">n_vox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

    <span class="c1"># Get the mean</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vol</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vol</span><span class="p">[:])])</span>
    <span class="n">vol_m_mean_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">-</span> <span class="n">u</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># (x_gl,i - u).^2</span>

    <span class="c1"># Sum of (x_gl,i - u).^2 over all i</span>
    <span class="n">sum_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vol_m_mean_s</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vol_m_mean_s</span><span class="p">[:])])</span>

    <span class="c1"># Get a meshgrid first</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">vol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">vol</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">vol</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sum_w</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_vox</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Distance mesh</span>
        <span class="n">temp_x</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">temp_y</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">temp_z</span> <span class="o">=</span> <span class="n">Z</span> <span class="o">-</span> <span class="n">Z</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># meshgrid of weigths</span>
        <span class="n">temp_dist_mesh</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">temp_x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">temp_y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">temp_z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Removing NaNs</span>
        <span class="n">temp_dist_mesh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">vol</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">temp_dist_mesh</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

        <span class="c1"># Running sum of weights</span>
        <span class="n">w_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp_dist_mesh</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">temp_dist_mesh</span><span class="p">[:])])</span>
        <span class="n">sum_w</span> <span class="o">=</span> <span class="n">sum_w</span> <span class="o">+</span> <span class="n">w_sum</span>

        <span class="c1"># Inside sum calculation</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">vol</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># x_gl,i</span>
        <span class="c1"># wij.*(x_gl,i - x_gl,j).^2</span>
        <span class="n">temp_vol</span> <span class="o">=</span> <span class="n">temp_dist_mesh</span><span class="o">*</span><span class="p">(</span><span class="n">vol</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># Removing i voxel to be sure;</span>
        <span class="n">temp_vol</span><span class="p">[</span><span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

        <span class="c1"># Sum of wij.*(x_gl,i - x_gl,j).^2 over all j</span>
        <span class="n">sum_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">temp_vol</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">temp_vol</span><span class="p">[:])])</span>

        <span class="c1"># Running sum of (sum of wij.*(x_gl,i - x_gl,j).^2 over all j) over all i</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">sum_val</span>

    <span class="n">geary_c</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_vox</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_s</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sum_w</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">geary_c</span></div>

<div class="viewcode-block" id="min_vol_ellipse"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.min_vol_ellipse">[docs]</a><span class="k">def</span> <span class="nf">min_vol_ellipse</span><span class="p">(</span><span class="n">P</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">tolerance</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Computes min_vol_ellipse.</span>
<span class="sd">    </span>
<span class="sd">    Finds the minimum volume enclsing ellipsoid (MVEE) of a set of data</span>
<span class="sd">    points stored in matrix P. The following optimization problem is solved:</span>

<span class="sd">        minimize $$log(det(A))$$ subject to $$(P_i - c)&#39; * A * (P_i - c) &lt;= 1$$</span>

<span class="sd">    in variables A and c, where `P_i` is the `i-th` column of the matrix `P`.</span>
<span class="sd">    The solver is based on Khachiyan Algorithm, and the final solution</span>
<span class="sd">    is different from the optimal value by the pre-spesified amount of</span>
<span class="sd">    `tolerance`.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        Adapted from MATLAB code of Nima Moshtagh (nima@seas.upenn.edu)</span>
<span class="sd">        University of Pennsylvania.</span>

<span class="sd">    Args:</span>
<span class="sd">        P (ndarray): (d x N) dimnesional matrix containing N points in R^d.</span>
<span class="sd">        tolerance (ndarray): error in the solution with respect to the optimal value.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        2-element tuple containing</span>
<span class="sd">    </span>
<span class="sd">        - A: (d x d) matrix of the ellipse equation in the &#39;center form&#39;: \</span>
<span class="sd">        $$(x-c)&#39; * A * (x-c) = 1$$ \</span>
<span class="sd">        where d is shape of `P` along 0-axis. </span>
<span class="sd">        </span>
<span class="sd">        - c: d-dimensional vector as the center of the ellipse. </span>

<span class="sd">    Examples:</span>

<span class="sd">        &gt;&gt;&gt;P = rand(5,100)</span>

<span class="sd">        &gt;&gt;&gt;[A, c] = :func:`min_vol_ellipse(P, .01)`</span>

<span class="sd">        To reduce the computation time, work with the boundary points only:</span>

<span class="sd">        &gt;&gt;&gt;K = :func:`convhulln(P)`</span>

<span class="sd">        &gt;&gt;&gt;K = :func:`unique(K(:))`</span>

<span class="sd">        &gt;&gt;&gt;Q = :func:`P(:,K)`</span>

<span class="sd">        &gt;&gt;&gt;[A, c] = :func:`min_vol_ellipse(Q, .01)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Solving the Dual problem</span>
    <span class="c1"># data points</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">Q</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="p">:]</span>

    <span class="c1"># initializations</span>
    <span class="n">err</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>  <span class="c1"># 1st iteration</span>
    <span class="n">new_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Khachiyan Algorithm</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="n">diag_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">trans_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">diag_u</span> <span class="o">@</span> <span class="n">trans_q</span>

        <span class="c1"># M the diagonal vector of an NxN matrix</span>
        <span class="n">inv_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">trans_q</span> <span class="o">@</span> <span class="n">inv_x</span> <span class="o">@</span> <span class="n">Q</span><span class="p">)</span>
        <span class="n">maximum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="n">step_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">maximum</span> <span class="o">-</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">maximum</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">new_u</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">step_size</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">step_size</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_u</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">new_u</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Computing the Ellipse parameters</span>
    <span class="c1"># Finds the ellipse equation in the &#39;center form&#39;:</span>
    <span class="c1"># (x-c)&#39; * A * (x-c) = 1</span>
    <span class="c1"># It computes a dxd matrix &#39;A&#39; and a d dimensional vector &#39;c&#39; as the center</span>
    <span class="c1"># of the ellipse.</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="c1"># the A matrix for the ellipse</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">P</span> <span class="o">@</span> <span class="n">u</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>  <span class="c1"># center of the ellipse</span>

    <span class="n">pup_t</span> <span class="o">=</span> <span class="n">P</span> <span class="o">@</span> <span class="n">U</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="n">c</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">a_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">pup_t</span> <span class="o">-</span> <span class="n">cct</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="n">a_inv</span>

    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">c</span></div>

<div class="viewcode-block" id="padding"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.padding">[docs]</a><span class="k">def</span> <span class="nf">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Padding the volume and masks.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple of 3 ndarray: Volume and masks after padding.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># PADDING THE VOLUME WITH A LAYER OF NaNs</span>
    <span class="c1"># (reduce mesh computation errors of associated mask)</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
    <span class="c1"># PADDING THE MASKS WITH A LAYER OF 0&#39;s</span>
    <span class="c1"># (reduce mesh computation errors of associated mask)</span>
    <span class="n">mask_int</span> <span class="o">=</span> <span class="n">mask_int</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">mask_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mask_int</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">mask_morph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">mask_morph</span><span class="p">,</span> <span class="n">pad_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span></div>

<div class="viewcode-block" id="get_variables"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.get_variables">[docs]</a><span class="k">def</span> <span class="nf">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                  <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                  <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                                            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                                            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                                            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                                            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                                            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                                            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Compute variables usefull to calculate morphological features.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">            XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple of 7 ndarray: Variables usefull to calculate morphological features.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># GETTING IMPORTANT VARIABLES</span>
    <span class="n">xgl_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">vol</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mask_int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">mask_int</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">xgl_morph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">vol</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mask_morph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">mask_morph</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># XYZ refers to [Xc,Yc,Zc] in ref. [1].</span>
    <span class="n">xyz_int</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_mesh</span><span class="p">(</span><span class="n">mask_int</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="c1"># XYZ refers to [Xc,Yc,Zc] in ref. [1].</span>
    <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span> <span class="o">=</span> <span class="n">get_mesh</span><span class="p">(</span><span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="c1"># [X,Y,Z] points of the convex hull.</span>
    <span class="c1"># conv_hull Matlab is conv_hull.simplices</span>
    <span class="n">conv_hull</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">xgl_int</span><span class="p">,</span> <span class="n">xgl_morph</span><span class="p">,</span> <span class="n">xyz_int</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">conv_hull</span></div>

<div class="viewcode-block" id="extract_all"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.extract_all">[docs]</a><span class="k">def</span> <span class="nf">extract_all</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">compute_moran_i</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                <span class="n">compute_geary_c</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Compute Morphological Features.</span>
<span class="sd">    This features refer to Morphological family in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        Moran&#39;s Index and Geary&#39;s C measure takes so much computation time. Please</span>
<span class="sd">        use `compute_moran_i` `compute_geary_c` carefully.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">            XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>
<span class="sd">        compute_moran_i (bool, optional): True to compute Moran&#39;s Index.</span>
<span class="sd">        compute_geary_c (bool, optional): True to compute Geary&#39;s C measure.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: `intensity` musy be either &quot;arbitrary&quot;, &quot;definite&quot;, &quot;filter&quot; or None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialization of final structure (Dictionary) containing all features.</span>
    <span class="n">morph</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Fmorph_vol&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_approx_vol&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_area&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_av&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_comp_1&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_comp_2&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_sph_dispr&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_sphericity&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_asphericity&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_com&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_diam&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_pca_major&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_pca_minor&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_pca_least&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_pca_elongation&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_pca_flatness&#39;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># until here</span>
             <span class="s1">&#39;Fmorph_v_dens_aabb&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_a_dens_aabb&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_v_dens_ombb&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_a_dens_ombb&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_v_dens_aee&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_a_dens_aee&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_v_dens_mvee&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_a_dens_mvee&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_v_dens_conv_hull&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_a_dens_conv_hull&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_integ_int&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_moran_i&#39;</span><span class="p">:</span> <span class="p">[],</span>
             <span class="s1">&#39;Fmorph_geary_c&#39;</span><span class="p">:</span> <span class="p">[]</span>
            <span class="p">}</span>

    <span class="c1">#Initialization</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">xgl_int</span><span class="p">,</span> <span class="n">xgl_morph</span><span class="p">,</span> <span class="n">xyz_int</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">conv_hull</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="c1"># STARTING COMPUTATION</span>
    <span class="c1"># In mm^3</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">get_mesh_volume</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_vol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span>  <span class="c1"># Volume</span>

    <span class="c1"># Approximate Volume</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_approx_vol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask_morph</span><span class="p">[:])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="c1"># Surface area</span>
    <span class="c1"># In mm^2</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">get_mesh_area</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_area&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span>

    <span class="c1"># Surface to volume ratio</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_av&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">volume</span>

    <span class="c1"># Compactness 1</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_comp_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">area</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>

    <span class="c1"># Compactness 2</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_comp_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">36</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">volume</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">area</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Spherical disproportion</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_sph_dispr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="p">(</span><span class="mi">36</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">volume</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Sphericity</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_sphericity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="mi">36</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">volume</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">/</span> <span class="n">area</span>

    <span class="c1"># Asphericity</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_asphericity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">area</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">36</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">volume</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Centre of mass shift</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_com&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_com</span><span class="p">(</span><span class="n">xgl_int</span><span class="p">,</span> <span class="n">xgl_morph</span><span class="p">,</span> <span class="n">xyz_int</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">)</span>

    <span class="c1"># Maximum 3D diameter</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_diam&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">]))</span>

    <span class="c1"># Major axis length</span>
    <span class="p">[</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">least</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_axis_lengths</span><span class="p">(</span><span class="n">xyz_morph</span><span class="p">)</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_pca_major&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">major</span><span class="p">)</span>

    <span class="c1"># Minor axis length</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_pca_minor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">minor</span><span class="p">)</span>

    <span class="c1"># Least axis length</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_pca_least&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">least</span><span class="p">)</span>

    <span class="c1"># Elongation</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_pca_elongation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">minor</span> <span class="o">/</span> <span class="n">major</span><span class="p">)</span>

    <span class="c1"># Flatness</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_pca_flatness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">least</span> <span class="o">/</span> <span class="n">major</span><span class="p">)</span>

    <span class="c1"># Volume density - axis-aligned bounding box</span>
    <span class="n">xc_aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">yc_aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">zc_aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">v_aabb</span> <span class="o">=</span> <span class="n">xc_aabb</span> <span class="o">*</span> <span class="n">yc_aabb</span> <span class="o">*</span> <span class="n">zc_aabb</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_v_dens_aabb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">v_aabb</span>

    <span class="c1"># Area density - axis-aligned bounding box</span>
    <span class="n">a_aabb</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">xc_aabb</span><span class="o">*</span><span class="n">yc_aabb</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">xc_aabb</span><span class="o">*</span><span class="n">zc_aabb</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">yc_aabb</span><span class="o">*</span><span class="n">zc_aabb</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_a_dens_aabb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a_aabb</span>

    <span class="c1"># Volume density - oriented minimum bounding box</span>
    <span class="c1"># Implementation of Chan and Tan&#39;s algorithm (C.K. Chan, S.T. Tan.</span>
    <span class="c1"># Determination of the minimum bounding box of an</span>
    <span class="c1"># arbitrary solid: an iterative approach.</span>
    <span class="c1"># Comp Struc 79 (2001) 1433-1449</span>
    <span class="n">bound_box_dims</span> <span class="o">=</span> <span class="n">min_oriented_bound_box</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">vol_bb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">bound_box_dims</span><span class="p">)</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_v_dens_ombb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">vol_bb</span>

    <span class="c1"># Area density - oriented minimum bounding box</span>
    <span class="n">a_ombb</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                    <span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>
                    <span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_a_dens_ombb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a_ombb</span>

    <span class="c1"># Volume density - approximate enclosing ellipsoid</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">major</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">minor</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">least</span><span class="p">)</span>
    <span class="n">v_aee</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_v_dens_aee&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">v_aee</span>

    <span class="c1"># Area density - approximate enclosing ellipsoid</span>
    <span class="n">a_aee</span> <span class="o">=</span> <span class="n">get_area_dens_approx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_a_dens_aee&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a_aee</span>

    <span class="c1"># Volume density - minimum volume enclosing ellipsoid</span>
    <span class="c1"># (Rotate the volume first??)</span>
    <span class="c1"># Copyright (c) 2009, Nima Moshtagh</span>
    <span class="c1"># http://www.mathworks.com/matlabcentral/fileexchange/</span>
    <span class="c1"># 9542-minimum-volume-enclosing-ellipsoid</span>
    <span class="c1"># Subsequent singular value decomposition of matrix A and and</span>
    <span class="c1"># taking the inverse of the square root of the diagonal of the</span>
    <span class="c1"># sigma matrix will produce respective semi-axis lengths.</span>
    <span class="c1"># Subsequent singular value decomposition of matrix A and</span>
    <span class="c1"># taking the inverse of the square root of the diagonal of the</span>
    <span class="c1"># sigma matrix will produce respective semi-axis lengths.</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">min_vol_ellipse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="c1"># New semi-axis lengths</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">v_mvee</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_v_dens_mvee&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">v_mvee</span>

    <span class="c1"># Area density - minimum volume enclosing ellipsoid</span>
    <span class="c1"># Using a new set of (a,b,c), see Volume density - minimum</span>
    <span class="c1"># volume enclosing ellipsoid</span>
    <span class="n">a_mvee</span> <span class="o">=</span> <span class="n">get_area_dens_approx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_a_dens_mvee&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a_mvee</span>

    <span class="c1"># Volume density - convex hull</span>
    <span class="n">v_convex</span> <span class="o">=</span> <span class="n">conv_hull</span><span class="o">.</span><span class="n">volume</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_v_dens_conv_hull&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">v_convex</span>

    <span class="c1"># Area density - convex hull</span>
    <span class="n">a_convex</span> <span class="o">=</span> <span class="n">conv_hull</span><span class="o">.</span><span class="n">area</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_a_dens_conv_hull&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a_convex</span>

    <span class="c1"># Integrated intensity</span>
    <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_integ_int&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xgl_int</span><span class="p">)</span> <span class="o">*</span> <span class="n">volume</span>

    <span class="c1"># Moran&#39;s I index</span>
    <span class="k">if</span> <span class="n">compute_moran_i</span><span class="p">:</span>
        <span class="n">vol_mor</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vol_mor</span><span class="p">[</span><span class="n">mask_int</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_moran_i&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_moran_i</span><span class="p">(</span><span class="n">vol_mor</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="c1"># Geary&#39;s C measure</span>
    <span class="k">if</span> <span class="n">compute_geary_c</span><span class="p">:</span>
        <span class="n">morph</span><span class="p">[</span><span class="s1">&#39;Fmorph_geary_c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_geary_c</span><span class="p">(</span><span class="n">vol_mor</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">morph</span></div>

<div class="viewcode-block" id="vol"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.vol">[docs]</a><span class="k">def</span> <span class="nf">vol</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
        <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
        <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
        <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes morphological volume feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_vol&quot; (ID = RNUO) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">            XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the morphological volume feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">get_mesh_volume</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">volume</span>  <span class="c1"># Morphological volume feature</span></div>

<div class="viewcode-block" id="approx_vol"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.approx_vol">[docs]</a><span class="k">def</span> <span class="nf">approx_vol</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes morphological approximate volume feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_approx_vol&quot; (ID = YEKZ) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the morphological approximate volume feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">volume_appro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask_morph</span><span class="p">[:])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">volume_appro</span>  <span class="c1"># Morphological approximate volume feature</span></div>

<div class="viewcode-block" id="area"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.area">[docs]</a><span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
         <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
         <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
         <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Surface area feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_area&quot; (ID = COJJK) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the surface area feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">get_mesh_area</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">area</span>  <span class="c1"># Surface area</span></div>

<div class="viewcode-block" id="av"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.av">[docs]</a><span class="k">def</span> <span class="nf">av</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
       <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
       <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
       <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Surface to volume ratio feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_av&quot; (ID = 2PR5) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Surface to volume ratio feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">volume</span>

    <span class="k">return</span> <span class="n">ratio</span>  <span class="c1"># Surface to volume ratio</span></div>

<div class="viewcode-block" id="comp_1"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.comp_1">[docs]</a><span class="k">def</span> <span class="nf">comp_1</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
           <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
           <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
           <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Compactness 1 feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_comp_1&quot; (ID = SKGS) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Compactness 1 feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">comp_1</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">area</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">comp_1</span>  <span class="c1"># Compactness 1</span></div>

<div class="viewcode-block" id="comp_2"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.comp_2">[docs]</a><span class="k">def</span> <span class="nf">comp_2</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
           <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
           <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
           <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Compactness 2 feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_comp_2&quot; (ID = BQWJ) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Compactness 2 feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">comp_2</span> <span class="o">=</span> <span class="mi">36</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">volume</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">area</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">comp_2</span>  <span class="c1"># Compactness 2</span></div>

<div class="viewcode-block" id="sph_dispr"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.sph_dispr">[docs]</a><span class="k">def</span> <span class="nf">sph_dispr</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Spherical disproportion feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_sph_dispr&quot; (ID = KRCK) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Spherical disproportion feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">sph_dispr</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="p">(</span><span class="mi">36</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">volume</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sph_dispr</span>  <span class="c1"># Spherical disproportion</span></div>

<div class="viewcode-block" id="sphericity"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.sphericity">[docs]</a><span class="k">def</span> <span class="nf">sphericity</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Sphericity feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_sphericity&quot; (ID = QCFX) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Sphericity feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">sphericity</span> <span class="o">=</span> <span class="p">((</span><span class="mi">36</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">volume</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">))</span> <span class="o">/</span> <span class="n">area</span>

    <span class="k">return</span> <span class="n">sphericity</span>  <span class="c1"># Sphericity</span></div>

<div class="viewcode-block" id="asphericity"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.asphericity">[docs]</a><span class="k">def</span> <span class="nf">asphericity</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Asphericity feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_asphericity&quot; (ID =  25C) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Asphericity feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">asphericity</span> <span class="o">=</span> <span class="p">((</span><span class="n">area</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">36</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">volume</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">asphericity</span>  <span class="c1"># Asphericity</span></div>

<div class="viewcode-block" id="com"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.com">[docs]</a><span class="k">def</span> <span class="nf">com</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
        <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
        <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
        <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Centre of mass shift feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_com&quot; (ID =  KLM) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Centre of mass shift feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">xgl_int</span><span class="p">,</span> <span class="n">xgl_morph</span><span class="p">,</span> <span class="n">xyz_int</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">com</span> <span class="o">=</span> <span class="n">get_com</span><span class="p">(</span><span class="n">xgl_int</span><span class="p">,</span> <span class="n">xgl_morph</span><span class="p">,</span> <span class="n">xyz_int</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">com</span>  <span class="c1"># Centre of mass shift</span></div>

<div class="viewcode-block" id="diam"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.diam">[docs]</a><span class="k">def</span> <span class="nf">diam</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
         <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
         <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
         <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Maximum 3D diameter feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_diam&quot; (ID = L0JK) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Maximum 3D diameter feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">conv_hull</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">diam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">vertices</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">diam</span>  <span class="c1"># Maximum 3D diameter</span></div>

<div class="viewcode-block" id="pca_major"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.pca_major">[docs]</a><span class="k">def</span> <span class="nf">pca_major</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Major axis length feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_pca_major&quot; (ID = TDIC) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                    XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Major axis length feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">[</span><span class="n">major</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_axis_lengths</span><span class="p">(</span><span class="n">xyz_morph</span><span class="p">)</span>
    <span class="n">pca_major</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">major</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pca_major</span>  <span class="c1"># Major axis length</span></div>

<div class="viewcode-block" id="pca_minor"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.pca_minor">[docs]</a><span class="k">def</span> <span class="nf">pca_minor</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Minor axis length feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_pca_minor&quot; (ID = P9VJ) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Minor axis length feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_axis_lengths</span><span class="p">(</span><span class="n">xyz_morph</span><span class="p">)</span>
    <span class="n">pca_minor</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">minor</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pca_minor</span>  <span class="c1"># Minor axis length</span></div>

<div class="viewcode-block" id="pca_least"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.pca_least">[docs]</a><span class="k">def</span> <span class="nf">pca_least</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Least axis length feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_pca_least&quot; (ID = 7J51) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Least axis length feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">least</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_axis_lengths</span><span class="p">(</span><span class="n">xyz_morph</span><span class="p">)</span>
    <span class="n">pca_least</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">least</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pca_least</span>  <span class="c1"># Least axis length</span></div>

<div class="viewcode-block" id="pca_elongation"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.pca_elongation">[docs]</a><span class="k">def</span> <span class="nf">pca_elongation</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                   <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                   <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                   <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Elongation feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_pca_elongation&quot; (ID = Q3CK) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Elongation feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">[</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_axis_lengths</span><span class="p">(</span><span class="n">xyz_morph</span><span class="p">)</span>
    <span class="n">pca_elongation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">minor</span> <span class="o">/</span> <span class="n">major</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pca_elongation</span>  <span class="c1"># Elongation</span></div>

<div class="viewcode-block" id="pca_flatness"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.pca_flatness">[docs]</a><span class="k">def</span> <span class="nf">pca_flatness</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                 <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                 <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                 <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Flatness feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_pca_flatness&quot; (ID = N17B) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Flatness feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">[</span><span class="n">major</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">least</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_axis_lengths</span><span class="p">(</span><span class="n">xyz_morph</span><span class="p">)</span>
    <span class="n">pca_flatness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">least</span> <span class="o">/</span> <span class="n">major</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pca_flatness</span>  <span class="c1"># Flatness</span></div>

<div class="viewcode-block" id="v_dens_aabb"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.v_dens_aabb">[docs]</a><span class="k">def</span> <span class="nf">v_dens_aabb</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Volume density - axis-aligned bounding box feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_v_dens_aabb&quot; (ID = PBX1) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Volume density - axis-aligned bounding box feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">xc_aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">yc_aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">zc_aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">v_aabb</span> <span class="o">=</span> <span class="n">xc_aabb</span> <span class="o">*</span> <span class="n">yc_aabb</span> <span class="o">*</span> <span class="n">zc_aabb</span>
    <span class="n">v_dens_aabb</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">v_aabb</span>

    <span class="k">return</span> <span class="n">v_dens_aabb</span>  <span class="c1"># Volume density - axis-aligned bounding box</span></div>

<div class="viewcode-block" id="a_dens_aabb"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.a_dens_aabb">[docs]</a><span class="k">def</span> <span class="nf">a_dens_aabb</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Area density - axis-aligned bounding box feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_a_dens_aabb&quot; (ID = R59B) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Area density - axis-aligned bounding box feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">xc_aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">yc_aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">zc_aabb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">a_aabb</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">xc_aabb</span><span class="o">*</span><span class="n">yc_aabb</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">xc_aabb</span><span class="o">*</span><span class="n">zc_aabb</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">yc_aabb</span><span class="o">*</span><span class="n">zc_aabb</span>
    <span class="n">a_dens_aabb</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a_aabb</span>

    <span class="k">return</span> <span class="n">a_dens_aabb</span>  <span class="c1"># Area density - axis-aligned bounding box</span></div>

<div class="viewcode-block" id="v_dens_ombb"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.v_dens_ombb">[docs]</a><span class="k">def</span> <span class="nf">v_dens_ombb</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Volume density - oriented minimum bounding box feature.</span>
<span class="sd">    Implementation of Chan and Tan&#39;s algorithm (C.K. Chan, S.T. Tan.</span>
<span class="sd">    Determination of the minimum bounding box of an</span>
<span class="sd">    arbitrary solid: an iterative approach.</span>
<span class="sd">    Comp Struc 79 (2001) 1433-1449.</span>
<span class="sd">    This feature refers to &quot;Fmorph_v_dens_ombb&quot; (ID = ZH1A) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Volume density - oriented minimum bounding box feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">bound_box_dims</span> <span class="o">=</span> <span class="n">min_oriented_bound_box</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">vol_bb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">bound_box_dims</span><span class="p">)</span>
    <span class="n">v_dens_ombb</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">vol_bb</span>

    <span class="k">return</span> <span class="n">v_dens_ombb</span>  <span class="c1"># Volume density - oriented minimum bounding box</span></div>

<div class="viewcode-block" id="a_dens_ombb"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.a_dens_ombb">[docs]</a><span class="k">def</span> <span class="nf">a_dens_ombb</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Area density - oriented minimum bounding box feature.</span>
<span class="sd">    Implementation of Chan and Tan&#39;s algorithm (C.K. Chan, S.T. Tan.</span>
<span class="sd">    Determination of the minimum bounding box of an</span>
<span class="sd">    arbitrary solid: an iterative approach.</span>
<span class="sd">    This feature refers to &quot;Fmorph_a_dens_ombb&quot; (ID = IQYR) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Area density - oriented minimum bounding box feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="n">bound_box_dims</span> <span class="o">=</span> <span class="n">min_oriented_bound_box</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">a_ombb</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> 
                <span class="o">+</span> <span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">bound_box_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">a_dens_ombb</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a_ombb</span>

    <span class="k">return</span> <span class="n">a_dens_ombb</span>  <span class="c1"># Area density - oriented minimum bounding box</span></div>

<div class="viewcode-block" id="v_dens_aee"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.v_dens_aee">[docs]</a><span class="k">def</span> <span class="nf">v_dens_aee</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Volume density - approximate enclosing ellipsoid feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_v_dens_aee&quot; (ID = 6BDE) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args: </span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Volume density - approximate enclosing ellipsoid feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">[</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">least</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_axis_lengths</span><span class="p">(</span><span class="n">xyz_morph</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">major</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">minor</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">least</span><span class="p">)</span>
    <span class="n">v_aee</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">v_dens_aee</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">v_aee</span>

    <span class="k">return</span> <span class="n">v_dens_aee</span>  <span class="c1"># Volume density - approximate enclosing ellipsoid</span></div>

<div class="viewcode-block" id="a_dens_aee"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.a_dens_aee">[docs]</a><span class="k">def</span> <span class="nf">a_dens_aee</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
               <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Area density - approximate enclosing ellipsoid feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_a_dens_aee&quot; (ID = RDD2) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Area density - approximate enclosing ellipsoid feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">xyz_morph</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="p">[</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">least</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_axis_lengths</span><span class="p">(</span><span class="n">xyz_morph</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">major</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">minor</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">least</span><span class="p">)</span>
    <span class="n">a_aee</span> <span class="o">=</span> <span class="n">get_area_dens_approx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">a_dens_aee</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a_aee</span>

    <span class="k">return</span> <span class="n">a_dens_aee</span>  <span class="c1"># Area density - approximate enclosing ellipsoid</span></div>

<div class="viewcode-block" id="v_dens_mvee"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.v_dens_mvee">[docs]</a><span class="k">def</span> <span class="nf">v_dens_mvee</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Volume density - minimum volume enclosing ellipsoid feature.</span>
<span class="sd">    Subsequent singular value decomposition of matrix A and and</span>
<span class="sd">    taking the inverse of the square root of the diagonal of the</span>
<span class="sd">    sigma matrix will produce respective semi-axis lengths.</span>
<span class="sd">    Subsequent singular value decomposition of matrix A and</span>
<span class="sd">    taking the inverse of the square root of the diagonal of the</span>
<span class="sd">    sigma matrix will produce respective semi-axis lengths.</span>
<span class="sd">    This feature refers to &quot;Fmorph_v_dens_mvee&quot; (ID = SWZ1) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Volume density - minimum volume enclosing ellipsoid feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">conv_hull</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">min_vol_ellipse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="c1"># New semi-axis lengths</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">v_mvee</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
    <span class="n">v_dens_mvee</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">v_mvee</span>

    <span class="k">return</span> <span class="n">v_dens_mvee</span>  <span class="c1"># Volume density - minimum volume enclosing ellipsoid</span></div>

<div class="viewcode-block" id="a_dens_mvee"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.a_dens_mvee">[docs]</a><span class="k">def</span> <span class="nf">a_dens_mvee</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Area density - minimum volume enclosing ellipsoid feature.</span>
<span class="sd">    Subsequent singular value decomposition of matrix A and and</span>
<span class="sd">    taking the inverse of the square root of the diagonal of the</span>
<span class="sd">    sigma matrix will produce respective semi-axis lengths.</span>
<span class="sd">    Subsequent singular value decomposition of matrix A and</span>
<span class="sd">    taking the inverse of the square root of the diagonal of the</span>
<span class="sd">    sigma matrix will produce respective semi-axis lengths.</span>
<span class="sd">    This feature refers to &quot;Fmorph_a_dens_mvee&quot; (ID = BRI8) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Area density - minimum volume enclosing ellipsoid feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">conv_hull</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">conv_hull</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">conv_hull</span><span class="o">.</span><span class="n">simplices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">min_vol_ellipse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mf">0.01</span><span class="p">)</span>
    <span class="c1"># New semi-axis lengths</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">a_mvee</span> <span class="o">=</span> <span class="n">get_area_dens_approx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">a_dens_mvee</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">a_mvee</span>

    <span class="k">return</span> <span class="n">a_dens_mvee</span>  <span class="c1"># Area density - minimum volume enclosing ellipsoid</span></div>

<div class="viewcode-block" id="v_dens_conv_hull"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.v_dens_conv_hull">[docs]</a><span class="k">def</span> <span class="nf">v_dens_conv_hull</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                     <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                     <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                     <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Volume density - convex hull feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_v_dens_conv_hull&quot; (ID = R3ER) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Volume density - convex hull feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">conv_hull</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">v_convex</span> <span class="o">=</span> <span class="n">conv_hull</span><span class="o">.</span><span class="n">volume</span>
    <span class="n">v_dens_conv_hull</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">v_convex</span>

    <span class="k">return</span> <span class="n">v_dens_conv_hull</span>  <span class="c1"># Volume density - convex hull</span></div>

<div class="viewcode-block" id="a_dens_conv_hull"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.a_dens_conv_hull">[docs]</a><span class="k">def</span> <span class="nf">a_dens_conv_hull</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                     <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                     <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
                     <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Area density - convex hull feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_a_dens_conv_hull&quot; (ID = 7T7F) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Area density - convex hull feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">conv_hull</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">v_convex</span> <span class="o">=</span> <span class="n">conv_hull</span><span class="o">.</span><span class="n">area</span>
    <span class="n">a_dens_conv_hull</span> <span class="o">=</span> <span class="n">area</span> <span class="o">/</span> <span class="n">v_convex</span>

    <span class="k">return</span> <span class="n">a_dens_conv_hull</span>  <span class="c1"># Area density - convex hull</span></div>

<div class="viewcode-block" id="integ_int"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.integ_int">[docs]</a><span class="k">def</span> <span class="nf">integ_int</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
              <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Integrated intensity feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_integ_int&quot; (ID = 99N0) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Integrated intensity feature.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>
    <span class="n">xgl_int</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_variables</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">integ_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xgl_int</span><span class="p">)</span> <span class="o">*</span> <span class="n">volume</span>

    <span class="k">return</span> <span class="n">integ_int</span>  <span class="c1"># Integrated intensity</span></div>

<div class="viewcode-block" id="moran_i"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.moran_i">[docs]</a><span class="k">def</span> <span class="nf">moran_i</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">compute_moran_i</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Moran&#39;s I index feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_moran_i&quot; (ID = N365) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>
<span class="sd">        compute_moran_i (bool, optional): True to compute Moran&#39;s Index.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Moran&#39;s I index feature.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">compute_moran_i</span><span class="p">:</span>
        <span class="n">vol_mor</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vol_mor</span><span class="p">[</span><span class="n">mask_int</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">moran_i</span> <span class="o">=</span> <span class="n">get_moran_i</span><span class="p">(</span><span class="n">vol_mor</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">moran_i</span>  <span class="c1"># Moran&#39;s I index</span></div>

<div class="viewcode-block" id="geary_c"><a class="viewcode-back" href="../../../biomarkers.html#MEDimage.biomarkers.morph.geary_c">[docs]</a><span class="k">def</span> <span class="nf">geary_c</span><span class="p">(</span><span class="n">vol</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">mask_int</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">mask_morph</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">res</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
            <span class="n">compute_geary_c</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Computes Geary&#39;s C measure feature.</span>
<span class="sd">    This feature refers to &quot;Fmorph_geary_c&quot; (ID = NPT7) in </span>
<span class="sd">    the `IBSI1 reference manual &lt;https://arxiv.org/pdf/1612.07003.pdf&gt;`_.</span>

<span class="sd">    Args:</span>
<span class="sd">        vol (ndarray): 3D volume, NON-QUANTIZED, continous imaging intensity distribution.</span>
<span class="sd">        mask_int (ndarray): Intensity mask.</span>
<span class="sd">        mask_morph (ndarray): Morphological mask.</span>
<span class="sd">        res (ndarray): [a,b,c] vector specfying the resolution of the volume in mm.</span>
<span class="sd">                       XYZ resolution (world), or JIK resolution (intrinsic matlab).</span>
<span class="sd">        compute_geary_c (bool, optional): True to compute Geary&#39;s C measure.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Value of the Geary&#39;s C measure feature.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">mask_int</span><span class="p">,</span> <span class="n">mask_morph</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">compute_geary_c</span><span class="p">:</span>
        <span class="n">vol_mor</span> <span class="o">=</span> <span class="n">vol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">vol_mor</span><span class="p">[</span><span class="n">mask_int</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">geary_c</span> <span class="o">=</span> <span class="n">get_geary_c</span><span class="p">(</span><span class="n">vol_mor</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">geary_c</span>  <span class="c1"># Geary&#39;s C measure</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, MEDimage.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>